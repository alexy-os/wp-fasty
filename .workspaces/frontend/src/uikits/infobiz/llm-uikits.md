# LLM UI Kit Generation Guidelines

## Overview

This guide outlines the process of converting raw HTML with Tailwind utility classes into a structured UI kit with semantic components following the Atomic Design methodology.

## Important Token Efficiency Guidelines

To optimize token usage and leverage the automated build system:

1. **NEVER generate CSS files** - CSS is automatically generated by the variant parser
2. **Focus ONLY on creating**:
   - Interface files (`interface.ts`) with proper variants and types
   - Component implementation files (`index.tsx`) with correct semantic class naming
3. **Use semantic class naming pattern**:
   ```jsx
   className={`component component-${variant} ${size !== "default" ? `component-${size}` : ""} ${className}`}
   ```
4. **Trust the system**:
   - The variants parser will extract all variants from your interface files
   - It will automatically generate CSS with the appropriate `@apply` directives
   - All class variants will be available without manual CSS creation

❗ **Remember**: Your task is only to analyze the structure, create interfaces with variants, and implement components with semantic class names. The CSS generation is automated.

## Color System & Theme

All UI components must use the shadcn color system based on oklch color space for better color perception and accessibility. 

- **Use CSS variables**: Always reference design tokens from the shadcn theme (`--primary`, `--destructive`, etc.)
- **Color format**: Use oklch color definitions for all component variants
- **Dark mode support**: Ensure all components work correctly in both light and dark modes
- **Color semantic names**: Follow the shadcn naming convention (primary, secondary, destructive, etc.)

Example of correct color usage:
```css
.component-primary {
  @apply bg-primary text-primary-foreground;
}

.component-destructive {
  @apply bg-destructive text-destructive-foreground;
}
```

The full color system includes:
- Background/foreground pairs for main surfaces
- Primary/secondary/accent colors with foreground variants
- Semantic colors (destructive, muted)
- Border, input, and ring colors
- Support for dark mode via CSS variables

## Directory Structure

```
src/
└── uikits/
    └── [kit-name]/
        └── core/
            ├── ui/          # Atoms - basic building blocks (buttons, inputs, badges)
            ├── components/  # Molecules - combinations of atoms (cards, navbars, tabs)
            └── blocks/      # Organisms - complex UI sections (heroes, feature sections, testimonials)
```

## Component Creation Process

1. **Analysis Phase**
   - Identify repeating patterns in the provided HTML
   - Categorize elements into atoms, molecules, and organisms
   - Extract common styling patterns into component variants

2. **Interface Definition**
   - Create `interface.ts` files with TypeScript types
   - Define variants, sizes, and other component properties
   - Use cva to define variant styles (will be processed by the variants parser)

3. **Component Implementation**
   - Create React components with props based on interfaces
   - Use semantic class naming in component templates
   - Follow the pattern: `className={componentName} ${componentName}-${variant}`

## Analysis Guidelines

### Atoms (UI)
- **Characteristics**: Single-purpose, non-divisible UI elements
- **Examples**: Buttons, inputs, texts, badges, icons
- **Variants**: Usually have multiple visual variants (primary, secondary, etc.)

### Molecules (Components)
- **Characteristics**: Combinations of atoms forming a functional unit
- **Examples**: Cards, form groups, navigation items, tab panels
- **Properties**: Often have multiple states and accept complex props

### Organisms (Blocks)
- **Characteristics**: Complex, complete UI sections that fulfill a specific purpose
- **Examples**: Hero sections, feature grids, pricing tables, testimonial carousels
- **Structure**: Typically composed of multiple components with their own layout

## Implementation Process

For each identified component:
   - Create interface file with all variants (using cva pattern)
   - Create component implementation file with semantic class naming
   - No need to create CSS files - they are generated automatically

For all components:
   - Ensure consistent naming conventions
   - Use the same pattern for class generation
   - Follow semantic naming principles

## Working with User Examples

When a user submits HTML with Tailwind classes:

1. Ask for the UI kit name if not provided
2. Analyze the HTML to identify component hierarchy
3. Extract UI patterns into atomic components
4. Create interfaces for each component using cva pattern
5. Implement React components using the interfaces with semantic class naming
6. Do not generate CSS files - they will be created automatically

## Example Workflow

For a submitted HTML snippet:

```html
<div class="rounded-lg bg-white p-6 shadow-md">
  <h3 class="text-xl font-bold text-gray-800">Card Title</h3>
  <p class="mt-2 text-gray-600">Card description goes here</p>
  <button class="mt-4 rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600">
    Click me
  </button>
</div>
```

The analysis would identify:
- A Button atom (with primary variant)
- A Card component (with default variant)

The implementation would create:
- `ui/button/interface.ts` with button variants defined using cva
- `ui/button/index.tsx` with the Button component using semantic class names
- `components/card/interface.ts` with card variants defined using cva
- `components/card/index.tsx` with the Card component using semantic class names

CSS files are not manually created - they are generated automatically by the variants parser based on the interface definitions.

## Best Practices

1. **Keep components focused**: Each component should do one thing well
2. **Maintain variant consistency**: Use the same variant names across components
3. **Follow semantic naming**: Component names should reflect their purpose
4. **Use TypeScript interfaces**: Provide good type definitions for components
5. **Document components**: Include prop documentation in interface files
6. **Consider accessibility**: Ensure components follow accessibility best practices

## Integration with Existing System

The system is designed to work with:
- Tailwind CSS v4 for utility classes with new features:
  - Native oklch color space support
  - New `@source` directive for content scanning
  - CSS nesting and logical properties
  - Built-in container queries
- React for component implementation
- TypeScript for type definitions
- Semantic CSS class generation for maintainability

### Tailwind 4 Specific Features

Components should leverage Tailwind 4 features for better maintainability:

```css
/* Using CSS nesting */
.card {
  @apply bg-card text-card-foreground;
  
  &-primary {
    @apply bg-primary text-primary-foreground;
  }
  
  &-header {
    @apply mb-4;
  }
}

/* Using oklch colors */
.component-gradient {
  @apply bg-gradient-to-br from-primary to-primary/70;
}
```

### Shadows and Elevation

Use the semantic shadcn shadow system for consistent elevation:

- **shadow-xs**: Subtle shadow for low elevation
- **shadow-sm**: Small shadow for slightly elevated components
- **shadow-md**: Medium shadow for elevated components
- **shadow-lg**: Large shadow for highly elevated components

Example:
```css
.card-elevation-sm {
  @apply shadow-sm;
}

.card-elevation-md {
  @apply shadow-md;
}
```

## Error Handling

If a user provides incomplete information:
1. Ask for clarification on component purpose
2. Request the UI kit name if not provided
3. Seek input on desired variants if unclear 

## Component Namespaces and CSS Compilation

### Namespace Structure

Components use a consistent namespace structure:

```javascript
// For UI components (atoms)
import { Button } from "@uikit-name/ui/button";

// For composite components (molecules)
import { Card } from "@uikit-name/components/card";

// For blocks (organisms)
import { Hero } from "@uikit-name/blocks/hero";
```

### CSS Compilation Process (Automated)

The system automatically handles CSS generation through a two-step process:

1. **Variants Parser**
   - Scans all interface.ts files to extract cva variants
   - Automatically generates CSS files with semantic class names
   - Creates variant classes based on the definitions

2. **Tailwind CLI**
   - Processes the main import.css file
   - Includes all semantic and utility classes
   - Outputs optimized CSS

**You do not need to understand the details of this process** - just create interface files with cva and implement components with semantic class names. The automation handles the rest.

## Converting Tailwind Classes to Semantic Components

### Analysis and Extraction Process

When converting HTML with Tailwind classes to semantic components:

1. **Group related classes**:
   - Identify base styles that apply to all instances of a component
   - Group variant-specific styles (colors, sizes, etc.)
   - Identify state-related styles (hover, focus, active)

2. **Create semantic mappings in interface files**:
   - Map base styles to component variants using cva
   - Define variants as TypeScript union types
   - Create default variants
   - Document the expected behaviors

3. **Build component with semantic class naming**:
   - Create components that use the interface definitions
   - Apply semantic class naming pattern for variants and sizes
   - Let the variants parser handle the CSS generation

### Example Conversion

**Original HTML with Tailwind**:
```html
<button class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md text-sm font-medium">
  Click me
</button>
```

**Extracted Component**:

Interface (button/interface.ts):
```typescript
import { cva } from 'class-variance-authority';

export type ButtonProps = {
  variant?: "primary" | "secondary" | "destructive" | "outline";
  size?: "sm" | "default" | "lg";
};

export const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        primary: "bg-primary text-primary-foreground hover:bg-primary/90",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 px-3 py-1",
        lg: "h-10 px-6 py-2"
      }
    },
    defaultVariants: {
      variant: "primary",
      size: "default"
    }
  }
);
```

Component (button/index.tsx):
```tsx
import { ButtonProps } from "./interface";

export function Button(props: ButtonProps & { 
  children: React.ReactNode;
  className?: string;
}) {
  const { variant = "primary", size = "default", className = "", children } = props;

  return (
    <button 
      className={`button button-${variant} ${size !== "default" ? `button-${size}` : ""} ${className}`}
    >
      {children}
    </button>
  );
}
```

Note that no CSS file is created - the variants parser will automatically generate CSS based on the cva definitions in the interface file.

### Handling Complex Patterns

For complex components with nested elements:

1. Define the structure in the interface:
   ```typescript
   import { cva } from 'class-variance-authority';
   
   export type CardProps = {
     variant?: "default" | "outline" | "primary";
     size?: "sm" | "default" | "lg";
   };
   
   export const cardVariants = cva(
     "rounded-lg border",
     {
       variants: {
         variant: {
           default: "bg-card text-card-foreground shadow",
           outline: "bg-transparent border-2",
           primary: "bg-primary text-primary-foreground"
         },
         size: {
           sm: "p-4",
           default: "p-6", 
           lg: "p-8"
         }
       },
       defaultVariants: {
         variant: "default",
         size: "default"
       }
     }
   );
   ```

2. Implement the component with semantic class names for each part:
   ```tsx
   import { CardProps } from "./interface";
   
   export function Card(props: CardProps & {
     header?: React.ReactNode;
     children: React.ReactNode;
     footer?: React.ReactNode;
     className?: string;
   }) {
     const { variant = "default", size = "default", header, children, footer, className = "" } = props;
   
     return (
       <div className={`card card-${variant} ${size !== "default" ? `card-${size}` : ""} ${className}`}>
         {header && <div className="card-header">{header}</div>}
         <div className="card-content">{children}</div>
         {footer && <div className="card-footer">{footer}</div>}
       </div>
     );
   }
   ```

The variants parser will handle creating CSS rules for all the nested elements based on the semantic naming pattern. 